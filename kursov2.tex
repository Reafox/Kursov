\documentclass[12pt,a4paper,oneside]{report}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}
\usepackage{tempora}

\usepackage{listings}
\lstset{inputencoding=utf8,extendedchars=false,keepspaces=true,mathescape} 
\usepackage{ccaption}
\usepackage{verbatim}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{syntax}
\usepackage{bytefield}
\usepackage{multicol}

\usepackage{algpseudocode}
\usepackage{graphicx}

\usepackage[dvipsnames,usenames]{color}
\usepackage{hyperref}
\hypersetup{unicode,breaklinks=true}
\usepackage{tikz}
\usetikzlibrary{arrows,decorations.pathmorphing,backgrounds,positioning,fit,petri,calc,shapes.misc,shapes.geometric}
%\usepackage{minted}
\usepackage{ifplatform}

%\usepackage[left=25mm, top=20mm, right=15mm, bottom=20mm]{geometry} % настройки полей документа

\usepackage{geometry}
	\geometry{top=20mm} %верх
	\geometry{bottom=20mm} %низ
	\geometry{left=25mm}
	\geometry{right=15mm}

%\textheight 20cm
%\textwidth 18cm

%\renewcommand{\rmdefault}{cmr}
%\renewcommand{\rmdefault}{ftm}

%\voffset 0mm
%\hoffset -7mm
%\oddsidemargin 0.0mm
%\evensidemargin 0.0mm
%\topmargin 0mm
%\footskip 10mm
%\topskip 10mm
\righthyphenmin=2
%\hfuzz=12.7pt

%\renewcommand{\baselinestretch}{1.3}
\usepackage{setspace}	
\onehalfspacing

\makeatletter
%\renewcommand\section{\@startsection {section}{1}{\z@}%
%                                   {3.5ex \@plus 1ex \@minus .2ex}%
%                                   {2.3ex \@plus.2ex}%
%                                   {\normalfont\Large\bfseries}}
%\renewcommand{\thesection}{\arabic{section}}
\@addtoreset{equation}{section}
\@addtoreset{figure}{section}
\@addtoreset{table}{section}

\newlength{\chaprule}
\newlength{\ATchapskip}
\setlength{\chaprule}{0.4\p@} \setlength{\ATchapskip}{10\p@} \advance \ATchapskip by -1\chaprule

\renewcommand{\@makechapterhead}[1]{%
    \ifdim\chaprule>6\p@ \setlength{\chaprule}{6\p@}\fi
    \vspace*{\ATchapskip}%
    %\noindent\rule{\textwidth}{\chaprule}\par%
    %\vskip 10\p@
    {\parindent \z@ \normalfont \ifnum \c@secnumdepth >\m@ne {\huge\bfseries \@chapapp\space \thechapter.}
        %\par\nobreak
        %\vskip 8\p@
        \fi \interlinepenalty\@M \huge\bfseries #1\par\nobreak \vskip 10\p@
        %\noindent\rule{\textwidth}{\chaprule}\par%
        \vskip\ATchapskip }}

%\@addtoreset{lstlisting}{section}
\makeatother

\newcommand{\dom}{\rm dom}
\newcounter{rem}[section]
\renewcommand{\therem}{\thesection.\arabic{rem}}
\newenvironment{Remark}{\par\refstepcounter{rem} \bf Замечание \therem. \sl}{\rm\par}
\renewcommand{\theequation}{\thesection.\arabic{equation}}
\renewcommand{\thefigure}{\thesection.\arabic{figure}}
\renewcommand{\thetable}{\thesection.\arabic{table}}
%\renewcommand{\thelstlisting}{\thesection.\arabic{lstlisting}}
\renewcommand{\lstlistingname}{Листинг}

\renewcommand{\theenumi}{\arabic{enumi}}
\renewcommand{\labelenumi}{\theenumi)}
\newcommand{\udc}[1]{УДК #1}

\newcounter{lem}[section]
\renewcommand{\thelem}{\thesection.\arabic{lem}}
\newenvironment{Lemma}{\par\refstepcounter{lem}\bf Лемма \thelem. \sl}{\rm\par}

\newcounter{cor}[section]
\renewcommand{\thecor}{\thesection.\arabic{cor}}
\newenvironment{Corrolary}{\par\refstepcounter{cor}\bf Следствие \thecor. \sl}{\rm\par}
\newcounter{theor}[section]
\renewcommand{\thetheor}{\thesection.\arabic{theor}}
\newenvironment{Theorem}{\par\refstepcounter{theor}\bf Теорема \thetheor. \sl}{\rm\par}
%\let \kappa=\ae
\newcommand{\diag}{\mathop{\rm diag}}
\newcommand{\epi}{\mathop{\rm epi}}
\newenvironment{Proof}{\par\noindent\bf Доказательство.\rm}{ \par}

\newcounter{exam}[section]
\renewcommand{\theexam}{\thesection.\arabic{exam}}
\newenvironment{Example}{\par\refstepcounter{exam}\bf Пример \theexam. \sl}{\rm\par}

\newcounter{prob}[section]
\renewcommand{\theprob}{\thesection.\arabic{prob}}
\newenvironment{Problem}{\par\refstepcounter{prob}\bf Задача \theprob. \sl}{\rm\par}

\newcounter{sol}[section]
\renewcommand{\thesol}{\thesection.\arabic{sol}}
\newenvironment{Solution}{\par\refstepcounter{sol}\bf Решение. \rm}{\rm\par}

\newcounter{defin}[section]
\renewcommand{\thedefin}{\thesection.\arabic{defin}}
\newenvironment{Definition}{\par\refstepcounter{defin}\bf Определение \thedefin.\sl}{\rm\par}

\newcounter{answ}[section]
\renewcommand{\theansw}{\thesection.\arabic{answ}}
\newenvironment{Answer}{\par\refstepcounter{answ}\theansw. \rm}{\rm\par}

\newcounter{exerc}[section]
\renewcommand{\theexerc}{\thesection.\arabic{exerc}}
\newenvironment{Exercise}{\par\refstepcounter{exerc}\bf Упражнение \theexerc.\sl}{\rm\par}

\newcounter{algor}[section]
\renewcommand{\thealgor}{\thesection.\arabic{algor}}
\newenvironment{Algorithm}[3]{\par\refstepcounter{algor}{\bf Алгоритм \thealgor. }{\sl #1}\par{\bf Вход: }{\sl #2}\par{\bf Выход: }\sl #3\par{\bf Метод.}\par}{\rm\par}

\newcommand{\ljoq}{<<}
\newcommand{\rjoq}{>>}
\newcommand{\vraisup}{\mathop{\rm vraisup}}
\newcommand{\pr}{\mathop{\rm pr}}
\newcommand{\sgn}{\mathop{\rm sgn}}
\newcommand{\epsclos}{\mathop{\text{$\varepsilon$--замыкание}}}
\newcommand{\move}{\mathop{\text{переход}}}
\newcommand{\closure}{\mathop{\text{ЗАМЫКАНИЕ}}}
\newcommand{\goto}{\mathop{\text{ПЕРЕХОД}}}
\newcommand{\ACTION}{\text{ДЕЙСТВИЕ}}
\newcommand{\GOTO}{\text{ПЕРЕХОД}}
\newcommand{\shift}[1]{\textbf{п}#1}
\newcommand{\reduce}[1]{\textbf{св}#1}
\newcommand{\access}{\textbf{доп}}
\captiondelim{. }

\makeatletter
\def\@seccntformat#1{\csname the#1\endcsname.\quad}
\makeatother

\algrenewcommand\algorithmicwhile{\textbf{пока}}
\algrenewcommand\algorithmicdo{\textbf{ }}
\algrenewcommand\algorithmicend{\textbf{конец}}
\algrenewcommand\algorithmicif{\textbf{если}}
\algrenewcommand\algorithmicthen{\textbf{то}}
\algrenewtext{EndIf}{\textbf{всё}}
\algrenewcommand\algorithmicfor{\textbf{для}}
\algrenewtext{ForAll}{\textbf{для всех }}
\algrenewcommand\algorithmicelse{\textbf{иначе}}
\algrenewtext{ElsIf}{\textbf{инес }}
\algrenewtext{Procedure}{\textbf{алг }}
\algrenewtext{EndProcedure}{\textbf{кон }}

\newcommand{\nad}[2]{\genfrac{}{}{0pt}{0}{#1}{#2}}

\newcommand{\nullable}{\mathop{\textit{зануляется}}}
\newcommand{\firstpos}{\mathop{\textit{первые}}}
\newcommand{\lastpos}{\mathop{\textit{последние}}}
\newcommand{\followpos}{\mathop{\textit{следующие}}}

\newcommand{\myor}{\mathop{\textbf{или}}}

\newcommand{\myand}{\mathop{\textbf{и}}}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\renewcommand{\syntleft}{\normalfont\itshape}
\renewcommand{\syntright}{}

\newcommand{\FIRST}{\text{ПЕРВЫЕ}}
\newcommand{\FOLLOW}{\text{СЛЕДУЮЩИЕ}}

\renewcommand{\theenumii}{\asbuk{enumii}}
\renewcommand{\labelenumii}{\theenumii)}

\date{}

\begin{document}	
	\begin{titlepage}	
		{\fontsize{14pt}{13pt}\selectfont
			\begin{center}
				МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ РОССИЙСКОЙ ФЕДЕРАЦИИ\\
				Федеральное государственное автономное образовательное учреждение\\
				высшего образования\\
				\textbf{«Национальный исследовательский\\Нижегородский государственный университет им. Н.И. Лобачевского»\\(ННГУ)\\
					\vspace{1cm}
					Институт информационных технологий, математики и механики\\
					\vspace{0.6cm}
					Кафедра прикладной математики\\}
				\vspace{0.8cm}
				Направление подготовки: Математика и компьютерные науки\\
				Профиль подготовки: общий\\
				\vspace{1cm}
				{\fontsize{18pt}{18pt}\selectfont \textbf{ОТЧЕТ\\}}
				по учебной практике\\
				\vspace{0.7cm}
				{\fontsize{16pt}{16pt}\selectfont \textbf{«Примеры программирования в кодах процессора МУР128М»}}
			\end{center}
			
			\vspace{2.5cm}
			
			\hfill\begin{minipage}{0.55\textwidth}
				\textbf {Выполнил:} студент группы
				\underline{\hspace{1.5cm}}\\
				\\
				\hspace*{2.7cm}
				\underline{\hspace{2.3cm}} ~Сарыкова А.\,А.\\
				\\
				\textbf {Научный руководитель:}\\К.ф.-м.н., доцент\\
				\hspace*{2.7cm}
				\underline{\hspace{2.3cm}} ~Гаврилов В.\,С.
			\end{minipage}
			
			\vfill
			
			\begin{center}
				Нижний Новгород \\ 
				2019 
			\end{center}
		}
		
\end{titlepage}

\tableofcontents
\setcounter{page}{2}

\chapter*{Введение}\addcontentsline{toc}{chapter}{Введение}
Данная работа посвящена реализации в машинных кодах процессора МУР128М некоторых численных методов одномерной оптимизации. А именно написаны программы, реализующие методы дихотомии и золотого сечения. Описание методов взято из \cite{Vasil'ev}, описание процессора МУР128М - из \cite{mur128}.

Работа состоит из введения и трёх глав. В первой главе находятся необходимые сведения из теории оптимизации. Во второй главе описана реализация методов дихотомии, а третья - посвящена реализации методов золотого сечения.

Первая глава состоит из трёх разделов. В первом разделе упоминается определение унимодальной функции и её основное свойство. Во втором разделе приводится краткое описание метода дихотомии. В третьем разделе - краткое описание метода золотого сечения.

Вторая глава состоит из шести разделов. В первом из разделов приводятся необходимые определения, заменяющие имена регистров. Во втором представлены ассемблерные макросы, упрощающие написание программы. В третьем приводится текст подпрограммы, реализующий метод дихотомии. Эта подпрограмма вызывается из основной программы. В четвёртом разделе представлена подпрограмма, реализующая минимизируемые функции. В пятом приведён текст основной программы. В последнем разделе представлен шеснадцатиричный дамп исполняемого файла программы.

Третья глава состоит из шести разделов. В первом из разделов приводятся необходимые определения, заменяющие имена регистров. Во втором представлены ассемблерные макросы, упрощающие написание программы. В третьем приводится текст подпрограммы, реализующий метод золотого сечения. Эта подпрограмма вызывается из основной программы. В четвёртом разделе представлена подпрограмма, реализующая минимизируемые функции. В пятом приведён текст основной программы. В последнем разделе представлен шеснадцатиричный дамп исполняемого файла программы.


\chapter{Сведения из теории оптимизации}
\section{Унимодальные функции}
Материал данного раздела взят из \cite[гл.1, опр.7]{Vasil'ev}.
\begin{Definition}\label{la1}
Функция $f(x)$ непрерывная на $[a, b]$ называется унимодальной, если найдутся числа $\alpha,\beta$ из ${R}$ такие, что 
\begin{enumerate}
\item $f(x)$ строго убывает на $[a, \alpha]$;
\item $f(x)$ минимизируема на $[\alpha, \beta]$;
\item $f(x)$ строго возрастает на $[\beta, b]$.    
\end{enumerate}    
\par
Один или два из этих отрезков могут иметь нулевую длину. 
\end{Definition}

\begin{equation}\label{eq1}
f(x) \rightarrow min, x \in [a, b]
\end{equation}

\begin{Definition}\label{}
Отрезком неопределённости называется всякий отрезок $[c, d] \subset [a,b]$ такой, что $[c, d] \cap [\alpha, \beta] \neq \varnothing$.
\end{Definition}

\begin{Definition}\label{}
Решением задачи \eqref{eq1} с точностью $\varepsilon>0$ называется отрезок неопределённости $[c, d]$, такой, что $|d-c|<2\varepsilon$.    
\end{Definition}

\begin{Lemma}{\textbf{(Основное свойство унимодальных функций):}}\label{l1}
Пусть $f(x): [a,b] \rightarrow \mathbb {R}$ - унимод.
Если $z_1, z_2 \in (a,b), z_1<z_2$, то, вычислив $f(z_1)$ и $f(z_2)$, можно найти отрезок неопределённости $[c,d] \subset [a,b]$ такой, что $|d-c|<|b-a|$. Именно:
\begin{enumerate}
\item если $f(z_1)<f(z_2)$, то $[a,z_2]$ - отрезок неопределённости;
\item если $f(z_1)>f(z_2)$, то $[z_1,b]$ - отрезок неопределённости;
\item если $f(z_1)=f(z_2)$, то $[z_1,z_2]$ - отрезок неопределённости.
\end{enumerate}
\end{Lemma}

\section{Метод дихотомии}
В данном разделе напомним метод дихотомии \cite[гл.1, пар.3]{Vasil'ev}.
В этом методе имеется параметр $\lambda>0$, причём $0<\lambda<\varepsilon$, где $\varepsilon$ требуемая точность вычислений.
Метод дихотомии следует схеме, сформулированной в лемме \ref{l1}, при этом точки $z_1$, $z_2$ выбираются следующим образом:    
\begin{equation}
z_1=\dfrac{a+b}{2}-\lambda,\qquad z_2=\dfrac{a+b}{2} + \lambda
\end{equation}
\begin{Remark}{\textbf{(оно касается всех методов, основанных на лемме):}}\label{}
можно сказать, что из-за приближённого характера вычислений случай $f(z_1)=f(z_2)$ (см. лемму) никогда не реализуется.
Т.е. бывает либо 1) $f(z_1)<f(z_2)$, либо 2) $f(z_1)>f(z_2)$.
Поэтому от отрезка неопределённости $[a,b]$ мы переходим либо к отрезку неопределённости $[a,z_2]$, либо - к $[z_1,b]$.
\end{Remark}

\section{Метод золотого сечения}
В данном разделе напомним метод золотого сечения \cite[гл.1, пар.4]{Vasil'ev}.
Точка $c \in [a,b]$ осуществляет деление отрезка [a,b], если 
\begin{equation}\label{eq2}
\dfrac{\text{длина}[a,b]}{max\{\text{длина}[a,c], \text{длина}[c,b]\}} = \dfrac{max\{\text{длина}[a,c], \text{длина}[c,b]\}}{min\{\text{длина}[a,c], \text{длина}[c,b]\}}
\end{equation}

Для $\forall$ отрезка [a,b] точка золотого сечения $c$ существует, и отношение (\ref{eq2}) не зависит от отрезка [a,b] и равно числу $\tau = \dfrac{1+\sqrt{5}}{2} \approx 1,62 \qquad$
($\dfrac{1}{\tau}=\dfrac{\sqrt{5}-1}{2}$).

Для $\forall$ отрезка [a,b] $\exists$ две точки золотого сечения $z_1$, $z_2$, которые симметричны относительно середины $\dfrac{a+b}{2}$ отрезка [a,b]. Они выбираются следующим образом:
\begin{equation}
z_1=a+(1-\dfrac{1}{\tau})(b-a),\qquad z_2=a+\dfrac{1}{\tau}(b-a),
\end{equation}
причём:
\begin{enumerate}
\item точка $z_1$ -- точка золотого сечения отрезка [a, $z_2$];
\item точка $z_2$ -- точка золотого сечения отрезка [$z_1$, b].
\end{enumerate}

\chapter{Реализация метода дихотомии}
\section{Определения}
Чтобы не использовать имена регистров, введём следующие определения на языке программирования ассемблер:
\begin{verbatim}
func    equ r1
temp    equ r2
a       equ f3
b       equ f4
lambda  equ f5
epsilon equ f6
c       equ f0
d       equ f2
m       equ f7
z1      equ f8
z2      equ f9
F1      equ f10
F2      equ f11
len     equ f12
\end{verbatim}

\section{Нужные макросы}
Для упрощения написания программы нам потребуется ряд ассемблерных макросов. Это макросы для вывода на экран строки, чтения и печати вещественного числа, выхода из программы.
\begin{verbatim}
macro printStr строка, длина
{
push r0-r2
movu r1, строка
movu r2, длина
movu r0, 1
trap 0x80
pop r0-r2
}
\end{verbatim}
\par
Сначала приведён макрос printStr для вывода на экран строки, у которого указываются два аргумента: адрес выводимой строки и её длина. При вызове макроса все регистры сохраняются.
\begin{verbatim}   
macro readF
{
push r0-r0
movu r0, 2
trap 0x80
pop r0-r0
}
\end{verbatim}
\par
Второй макрос readF предназначен для чтения вещественного числа. На этом шаге программа приостанавливается и ожидает ввода пользователем вещественного числа, которое заносится в регистр f0.
\begin{verbatim} 
macro printF
{
push r0-r0
movu r0, 3
trap 0x80
pop r0-r0
}
\end{verbatim}
\par
Следующий макрос printF для печати вещественного числа. Программа выводит то число, которое было введено пользователем и содержится в регистре f0.
\begin{verbatim} 
macro exit0
{
movu r0, 4
movu r1, 0
trap 0x80
}
\end{verbatim}
\par
Последний макрос exit0 для выхода из программы. Программа успешно завершается с кодом ошибки 0, то есть без ошибок.

\section{Подпрограмма метода дихотомии}
Ниже приведён текст подпрограммы реализации метода дихотомии, при этом аргументы a, b, $\lambda$, $\varepsilon$ заносятся, согласно определениям в пункте 2.1, в соответствующие регистры f3, f4, f5, f6. Ссылка на функцию заносится в регистр r1. Результат работы подпрограммы дихотомии будет в регистре r0.

\begin{verbatim}
дихотомия:
push f3-f12
push r1-r2
add epsilon, epsilon, epsilon
цикл:
subf len, b, a
absf len, len
cmpf temp, len, epsilon
jmpsr temp, выход
addf m, a, b
mul2f m, m, -1
subf z1, m, lambda
addf z2, m, lambda
mov f0, z1
call func
mov F1, f0
mov f0, z2
call func
mov F2, f0
cmpt temp, F1, F2
jmpger temp, больше_или_равно
mov b, z2
jmpr цикл
больше_или_равно:
jmpzr temp, равно
mov a, z1
jmpr цикл    
равно:
mov a, z1
mov b, z2
jmpr цикл
выход:
mov c, a
mov d, b
pop r1-r2
pop f3-f12
ret
\end{verbatim}

\section{Минимизируемые функции}
В качестве минимизируемых функций возьмём функции $f_1(x)=x^3-x=x*(x^2-1)$ и \\
$f_2(x)=x^3-x^2=x^2*(x-1)$. 
\\Приведён текст подпрограммы. Аргумент функции заносится в регистр f0. После выполнения функции её значение находится также в f0.

\begin{multicols}{2}
\begin{verbatim}
func1:
push f1-f2
mulf f1, f0, f0 
fld1 f2
subf f1, f1, f2
mulf f0, f1, f0
pop f1-f2
ret

func2:
push f1-f2
fld1 f2
subf f1, f0, f2
mulf f0, f0, f0
mulf f0, f1, f0
pop	f1-f2
ret
\end{verbatim}
\end{multicols}


\section{Основная программа}
Приведён текст основной программы для первой и второй функции соответственно.
\begin{multicols}{2}
\begin{verbatim}
printStr 0x4140,0x1A
readF
mov a, f0
readF
mov b, f0
readF
mov lambda, f0
readF
mov epsilon, f0
mov func, func1
callr дихотомия
printStr 0x415A,0x14    
printF
exit0

printStr 0x4140,0x1A
readF
mov a, f0
readF
mov b, f0
readF
mov lambda, f0
readF
mov epsilon, f0
mov func, func2
callr дихотомия
printStr 0x415A,0x14    
printF
exit0
\end{verbatim}
\end{multicols}

\section{Дампы программы}
Ниже представлены шестнадцатеричные дампы исполняемого файла программы для обеих функций.
\\Для функции $f_1(x)=x^3-x=x*(x^2-1)$:
\begin{verbatim}
0000:0000  CC D3 D0 31  32 38 CC 00  00 40 00 00  00 00 00 00
0000:0010  00 00 00 00  00 00 00 00  00 04 00 00  00 00 00 00
0000:0020  00 00 00 00  00 00 00 00  D0 01 00 00  00 00 00 00
0000:0030  00 00 00 00  00 00 00 00  2D 00 00 00  00 00 00 00
0000:0040  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
0000:0050  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
0000:0060  00 00 00 00  00 00 00 00  88 00 00 00  00 00 00 00
0000:0070  00 00 00 00  00 00 00 00  40 01 00 00  00 00 00 00
0000:0080  00 00 00 00  00 00 00 00  C1 10 08 00  C0 10 C1 40
0000:0090  C0 11 00 1A  C0 10 00 01  84 00 00 80  C1 20 08 00
0000:00A0  C1 B0 00 00  C0 10 00 02  84 00 00 80  C1 C0 00 00
0000:00B0  C1 31 80 00  C1 B0 00 00  C0 10 00 02  84 00 00 80
0000:00C0  C1 C0 00 00  C1 32 00 00  C1 B0 00 00  C0 10 00 02
0000:00D0  84 00 00 80  C1 C0 00 00  C1 32 80 00  C1 B0 00 00
0000:00E0  C0 10 00 02  84 00 00 80  C1 C0 00 00  C1 33 00 00
0000:00F0  C0 10 C1 24  82 30 00 0E  C1 10 08 00  C0 10 C1 5A
0000:0100  C0 11 00 14  C0 10 00 01  84 00 00 80  C1 20 08 00
0000:0110  C1 B0 00 00  C0 10 00 03  84 00 00 80  C1 C0 00 00
0000:0120  C0 10 00 04  C0 10 80 00  84 00 00 80  C1 B1 B0 00
0000:0130  C1 10 88 00  40 03 18 C0  40 16 10 60  40 A6 30 00
0000:0140  40 41 30 C0  80 F1 00 15  40 03 8C 80  40 B3 9F E0
0000:0150  40 14 1C A0  40 A4 9C A0  C1 30 20 00  81 50 80 00
0000:0160  C1 35 00 00  C1 30 24 00  81 50 80 00  C1 35 80 00
0000:0170  40 41 29 60  81 31 00 03  C1 32 24 00  80 EF FF EF
0000:0180  81 01 80 03  C1 31 A0 00  80 EF FF EC  C1 31 A0 00
0000:0190  C1 32 24 00  80 EF FF E9  C1 30 0C 00  C1 30 90 00
0000:01A0  C1 20 88 00  C1 C1 B0 00  82 A0 00 00  C1 B0 88 00
0000:01B0  40 20 80 00  C1 D1 00 00  40 10 84 40  40 20 04 00
0000:01C0  C1 C0 88 00  82 A0 00 00  00 00 00 00  00 00 00 00
0000:01D0  D0 92 D0 B2  D0 B5 D0 B4  D0 B8 D1 82  D0 B5 20 61
0000:01E0  2C 62 2C CE  BB 2C CE B5  3A 0A D0 A0  D0 B5 D0 B7
0000:01F0  D1 83 D0 BB  D1 8C D1 82  D0 B0 D1 82  3A 0A
\end{verbatim}

Для функции $f_2(x)=x^3-x^2=x^2*(x-1)$:
\begin{verbatim}
0000:0000  CC D3 D0 31  32 38 CC 00  00 40 00 00  00 00 00 00
0000:0010  00 00 00 00  00 00 00 00  00 04 00 00  00 00 00 00
0000:0020  00 00 00 00  00 00 00 00  D0 01 00 00  00 00 00 00
0000:0030  00 00 00 00  00 00 00 00  2D 00 00 00  00 00 00 00
0000:0040  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
0000:0050  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
0000:0060  00 00 00 00  00 00 00 00  88 00 00 00  00 00 00 00
0000:0070  00 00 00 00  00 00 00 00  40 01 00 00  00 00 00 00
0000:0080  00 00 00 00  00 00 00 00  C1 10 08 00  C0 10 C1 40
0000:0090  C0 11 00 1A  C0 10 00 01  84 00 00 80  C1 20 08 00
0000:00A0  C1 B0 00 00  C0 10 00 02  84 00 00 80  C1 C0 00 00
0000:00B0  C1 31 80 00  C1 B0 00 00  C0 10 00 02  84 00 00 80
0000:00C0  C1 C0 00 00  C1 32 00 00  C1 B0 00 00  C0 10 00 02
0000:00D0  84 00 00 80  C1 C0 00 00  C1 32 80 00  C1 B0 00 00
0000:00E0  C0 10 00 02  84 00 00 80  C1 C0 00 00  C1 33 00 00
0000:00F0  C0 10 C1 24  82 30 00 0E  C1 10 08 00  C0 10 C1 5A
0000:0100  C0 11 00 14  C0 10 00 01  84 00 00 80  C1 20 08 00
0000:0110  C1 B0 00 00  C0 10 00 03  84 00 00 80  C1 C0 00 00
0000:0120  C0 10 00 04  C0 10 80 00  84 00 00 80  C1 B1 B0 00
0000:0130  C1 10 88 00  40 03 18 C0  40 16 10 60  40 A6 30 00
0000:0140  40 41 30 C0  80 F1 00 15  40 03 8C 80  40 B3 9F E0
0000:0150  40 14 1C A0  40 A4 9C A0  C1 30 20 00  81 50 80 00
0000:0160  C1 35 00 00  C1 30 24 00  81 50 80 00  C1 35 80 00
0000:0170  40 41 29 60  81 31 00 03  C1 32 24 00  80 EF FF EF
0000:0180  81 01 80 03  C1 31 A0 00  80 EF FF EC  C1 31 A0 00
0000:0190  C1 32 24 00  80 EF FF E9  C1 30 0C 00  C1 30 90 00
0000:01A0  C1 20 88 00  C1 C1 B0 00  82 A0 00 00  C1 B0 88 00
0000:01B0  C1 D1 00 00  40 10 80 40  40 20 00 00  40 20 04 00
0000:01C0  C1 C0 88 00  82 A0 00 00  00 00 00 00  00 00 00 00
0000:01D0  D0 92 D0 B2  D0 B5 D0 B4  D0 B8 D1 82  D0 B5 20 61
0000:01E0  2C 62 2C CE  BB 2C CE B5  3A 0A D0 A0  D0 B5 D0 B7
0000:01F0  D1 83 D0 BB  D1 8C D1 82  D0 B0 D1 82  3A 0A
\end{verbatim}

\chapter{Реализация метода золотого \-сечения}
\section{Определения}
Чтобы не использовать имена регистров, введём следующие определения на языке программирования ассемблер:
\begin{verbatim}
func        equ r1
temp        equ r2
adr_tay     equ r3
a           equ f3
b           equ f4
tay         equ f5
epsilon     equ f6
m           equ f7
z1          equ f8
z2          equ f9
F1          equ f10
F2          equ f11
len         equ f12
tempF       equ f2
\end{verbatim}

\section{Нужные макросы}
Для упрощения написания программы нам потребуется ряд ассемблерных макросов. Это макросы для вывода на экран строки, чтения и печати вещественного числа, выхода из программы.
\begin{verbatim}
macro printStr строка, длина
{
push r0-r2
movu r1, строка
movu r2, длина
movu r0, 1
trap 0x80
pop r0-r2
}
\end{verbatim}
\par
Сначала приведён макрос printStr для вывода на экран строки, у которого указываются два аргумента: адрес выводимой строки и её длина. При вызове макроса все регистры сохраняются.
\begin{verbatim}   
macro readF
{
push r0-r0
movu r0, 2
trap 0x80
pop r0-r0
}
\end{verbatim}
\par
Второй макрос readF предназначен для чтения вещественного числа. На этом шаге программа приостанавливается и ожидает ввода пользователем вещественного числа, которое заносится в регистр f0.
\begin{verbatim} 
macro printF
{
push r0-r0
movu r0, 3
trap 0x80
pop r0-r0
}
\end{verbatim}
\par
Следующий макрос printF для печати вещественного числа. Программа выводит то число, которое было введено пользователем и содержится в регистре f0.
\begin{verbatim} 
macro exit0
{
movu r0, 4
movu r1, 0
trap 0x80
}
\end{verbatim}
\par
Последний макрос exit0 для выхода из программы. Программа успешно завершается с кодом ошибки 0, то есть без ошибок.

\section{Подпрограмма метода золотого сечения}
Ниже приведён текст подпрограммы реализации метода золотого сечения, при этом аргументы a, b, $\tau$, $\varepsilon$ заносятся, согласно определениям в пункте 3.1, в соответствующие регистры f3, f4, f5, f6. Ссылка на функцию заносится в регистр r1. Результат работы подпрограммы золотого сечения будет в регистре r0.

\begin{verbatim}
золотое сечение:
push f2-f12
push r1-r3
movu adr_tay,0x4168
movu temp,0x0000
mov tay,[adr_tay+temp*1]
fld1 m
subf m,m,tay
subf len,b,a
mulf z1,m,len
addf z1,a,z1
mulf z2,tay,len
addf z2,a,z2
mov f0,z1
call func
mov F1,f0
mov f0,z2
call func
mov F2,f0
цикл:
absf tempF,len
cmpf temp,tempF,epsilon
jmpsr temp,выход
cmpf temp,F1,F2
jmpger temp,больше_или_равно
mov b,z2
subf len,b,a
mov z2,z1
mov F2,F1
mulf z1,m,len
addf z1,a,z1
mov f0,z1
call func
mov F1,f0
jmpr цикл
больше_или_равно:
mov a,z1
subf len,b,a
mov z1,z2
mov F1,F2
mulf z2,m,len
addf z2,a,z2
mov f0,z2
call func
mov F2,f0
jmpr цикл
выход:
addf len,a,b
mul2f f0,len,-1
pop r1-r3
pop f2-f12
ret
\end{verbatim}

\section{Минимизируемые функции}
В качестве минимизируемых функций возьмём функции $f_1(x)=x^3-x=x*(x^2-1)$ и \\
$f_2(x)=x^3-x^2=x^2*(x-1)$. 
\\Приведён текст подпрограммы. Аргумент функции заносится в регистр f0. После выполнения функции её значение находится также в f0.
\begin{multicols}{2}
\begin{verbatim}
func1:
push f1-f2
mulf f1, f0, f0 
fld1 f2
subf f1, f1, f2
mulf f0, f1, f0
pop f1-f2
ret

func2:
push f1-f2
fld1 f2
subf f1, f0, f2
mulf f0, f0, f0
mulf f0, f1, f0
pop f1-f2
ret
\end{verbatim}
\end{multicols}

\section{Основная программа}
Приведён текст основной программы для первой и второй функции соответственно.
%\begin{multicols}{2}
\begin{verbatim}
printStr 0x4178,0x1A
readF
mov a, f0
readF
mov b, f0
readF
mov epsilon, f0
readF
mov func, func1
callr золотое сечение
printStr 0x4192,0x14
printF
exit0

printStr 0x4178,0x1A
readF
mov a, f0
readF
mov b, f0
readF
mov epsilon, f0
readF
mov func, func2
callr золотое сечение
printStr 0x4192,0x14
printF
exit0
\end{verbatim}
%\end{multicols}

\section{Дампы программы}
Ниже представлены шестнадцатеричные дампы исполняемого файла программы для обеих функций.
\\Для функции $f_1(x)=x^3-x=x*(x^2-1)$:

\begin{verbatim}
0000:0000  CC D3 D0 31  32 38 CC 00  00 40 00 00  00 00 00 00
0000:0010  00 00 00 00  00 00 00 00  00 04 00 00  00 00 00 00
0000:0020  00 00 00 00  00 00 00 00  F0 01 00 00  00 00 00 00
0000:0030  00 00 00 00  00 00 00 00  3D 00 00 00  00 00 00 00
0000:0040  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
0000:0050  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
0000:0060  00 00 00 00  00 00 00 00  88 00 00 00  00 00 00 00
0000:0070  00 00 00 00  00 00 00 00  68 01 00 00  00 00 00 00
0000:0080  00 00 00 00  00 00 00 00  C1 10 08 00  C0 10 C1 78
0000:0090  C0 11 00 1A  C0 10 00 01  84 00 00 80  C1 20 08 00
0000:00A0  C1 10 00 00  C0 10 00 02  84 00 00 80  C1 20 00 00
0000:00B0  C1 31 80 00  C1 10 00 00  C0 10 00 02  84 00 00 80
0000:00C0  C1 20 00 00  C1 32 00 00  C1 10 00 00  C0 10 00 02
0000:00D0  84 00 00 80  C1 20 00 00  C1 32 80 00  82 30 00 0E
0000:00E0  C1 10 08 00  C0 10 C1 92  C0 11 00 14  C0 13 00 00
0000:00F0  84 00 00 80  C1 20 08 00  C1 10 00 00  C0 10 00 03
0000:0100  84 00 00 80  C1 20 00 00  C0 10 00 04  C0 10 80 01
0000:0110  84 00 00 80  C1 B1 30 80  C1 10 8C 00  C0 11 C1 68
0000:0120  C0 11 00 00  C1 42 8C 40  C1 D3 80 00  40 13 9C A0
0000:0130  40 16 10 60  40 24 1D 80  40 04 0D 00  40 24 95 80
0000:0140  40 04 8D 20  C1 30 20 00  81 50 80 00  C1 35 00 00
0000:0150  C1 30 24 00  81 50 80 00  C1 35 80 00  40 A1 30 00
0000:0160  40 41 08 C0  80 F1 00 17  40 41 29 60  81 31 00 0B
0000:0170  C1 32 24 00  40 16 10 60  C1 34 A0 00  C1 35 A8 00
0000:0180  40 24 1D 80  40 04 0D 00  C1 30 20 00  81 50 80 00
0000:0190  C1 35 00 00  80 EF FF F2  C1 31 A0 00  40 16 10 60
0000:01A0  C1 34 24 00  C1 35 2C 00  40 24 9D 80  40 04 8D 20
0000:01B0  C1 30 24 00  81 50 80 00  C1 35 80 00  80 EF FF E8
0000:01C0  40 06 0C 80  40 C0 33 FF  C1 20 8C 00  C1 C1 30 00
0000:01D0  82 A0 00 00  C1 B0 88 00  40 20 80 00  C1 D1 00 00
0000:01E0  40 10 84 40  40 20 04 00  C1 C0 88 00  82 A0 00 00 
0000:01F0  DC B9 C0 80  39 E7 2B F8  94 FE 72 F3  6E 3C FE 3F
0000:0200  D0 92 D0 B2  D0 B5 D0 B4  D0 B8 D1 82  D0 B5 20 61
0000:0210  2C 20 62 2C  20 45 3A 22  2C 0A D0 A0  D0 B5 D0 B7
0000:0220  D1 83 D0 BB  D1 8C D1 82  D0 B0 D1 82  3A 0A
\end{verbatim}

Для функции $f_2(x)=x^3-x^2=x^2*(x-1)$:
\begin{verbatim}
0000:0000  CC D3 D0 31  32 38 CC 00  00 40 00 00  00 00 00 00
0000:0010  00 00 00 00  00 00 00 00  00 04 00 00  00 00 00 00
0000:0020  00 00 00 00  00 00 00 00  F0 01 00 00  00 00 00 00
0000:0030  00 00 00 00  00 00 00 00  3D 00 00 00  00 00 00 00
0000:0040  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
0000:0050  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
0000:0060  00 00 00 00  00 00 00 00  88 00 00 00  00 00 00 00
0000:0070  00 00 00 00  00 00 00 00  68 01 00 00  00 00 00 00
0000:0080  00 00 00 00  00 00 00 00  C1 10 08 00  C0 10 C1 78
0000:0090  C0 11 00 1A  C0 10 00 01  84 00 00 80  C1 20 08 00
0000:00A0  C1 10 00 00  C0 10 00 02  84 00 00 80  C1 20 00 00
0000:00B0  C1 31 80 00  C1 10 00 00  C0 10 00 02  84 00 00 80
0000:00C0  C1 20 00 00  C1 32 00 00  C1 10 00 00  C0 10 00 02
0000:00D0  84 00 00 80  C1 20 00 00  C1 32 80 00  82 30 00 0E
0000:00E0  C1 10 08 00  C0 10 C1 92  C0 11 00 14  C0 13 00 00
0000:00F0  84 00 00 80  C1 20 08 00  C1 10 00 00  C0 10 00 03
0000:0100  84 00 00 80  C1 20 00 00  C0 10 00 04  C0 10 80 01
0000:0110  84 00 00 80  C1 B1 30 80  C1 10 8C 00  C0 11 C1 68
0000:0120  C0 11 00 00  C1 42 8C 40  C1 D3 80 00  40 13 9C A0
0000:0130  40 16 10 60  40 24 1D 80  40 04 0D 00  40 24 95 80
0000:0140  40 04 8D 20  C1 30 20 00  81 50 80 00  C1 35 00 00
0000:0150  C1 30 24 00  81 50 80 00  C1 35 80 00  40 A1 30 00
0000:0160  40 41 08 C0  80 F1 00 17  40 41 29 60  81 31 00 0B
0000:0170  C1 32 24 00  40 16 10 60  C1 34 A0 00  C1 35 A8 00
0000:0180  40 24 1D 80  40 04 0D 00  C1 30 20 00  81 50 80 00
0000:0190  C1 35 00 00  80 EF FF F2  C1 31 A0 00  40 16 10 60
0000:01A0  C1 34 24 00  C1 35 2C 00  40 24 9D 80  40 04 8D 20
0000:01B0  C1 30 24 00  81 50 80 00  C1 35 80 00  80 EF FF E8
0000:01C0  40 06 0C 80  40 C0 33 FF  C1 20 8C 00  C1 C1 30 00
0000:01D0  82 A0 00 00  C1 B0 88 00  C1 D1 00 00  40 10 80 40
0000:01E0  40 20 00 00  40 20 04 00  C1 C0 88 00  82 A0 00 00
0000:01F0  DC B9 C0 80  39 E7 2B F8  94 FE 72 F3  6E 3C FE 3F
0000:0200  D0 92 D0 B2  D0 B5 D0 B4  D0 B8 D1 82  D0 B5 20 61
0000:0210  2C 20 62 2C  20 45 3A 22  2C 0A D0 A0  D0 B5 D0 B7
0000:0220  D1 83 D0 BB  D1 8C D1 82  D0 B0 D1 82  3A 0A
\end{verbatim}

\chapter*{Заключение}\addcontentsline{toc}{chapter}{Заключение}
В данной работе были изучены методы одномерной оптимизации, а именно методы дихотомии и золотого сечения. Разработанные алгоритмы поиска экстремума заданных функций перенесены сначала на язык ассемблера, а затем на машинный код процессора МУР128М. Эти программы, написанные для реализаций методов половинного деления и золотого сечения, в дальнейшем послужат тестами для эмулятора МУР128М.

\renewcommand{\bibname}{Список литературы}
\begin{thebibliography}{99}\addcontentsline{toc}{chapter}{Список литературы}
\bibitem{Vasil'ev} Васильев Ф.П. Численные методы решения экстремальных задач / Васильев Ф.П. ---2-е изд. --- М.: Наука, 1988. --- 552с.
\bibitem{mur128} Гаврилов В.С. Процессор МУР128M (машина учебная регистровая, 128--разрядная) -- Режим доступа: \url{http://github.com/gavr-vlad-s/mur128m}
\end{thebibliography}  


\end{document}